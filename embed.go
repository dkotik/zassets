package zassets

import (
	"archive/zip"
	"crypto/md5"
	"crypto/sha256"
	"errors"
	"fmt"
	"hash"
	"io"
	"log"
	"os"
	"path"
	"strconv"
	"strings"
	"text/template"

	"github.com/OneOfOne/xxhash"
	"github.com/dkotik/zassets/compile"
)

// EmbedFunctions provides helpers for the file generation throug template.
var EmbedFunctions = template.FuncMap{
	"tags": func(tags []string) string {
		return strings.Join(tags, `,`)
	},
	"quote": strconv.Quote,
	"comment": func(s string) string {
		result := strings.SplitAfter(s, "\n")
		return `// ` + strings.Join(result, `// `)
	},
}
var defaultTemplate = template.Must(template.New(`default`).Funcs(EmbedFunctions).Parse(`
{{- define "header" -}}
// Code generated by github.com/dkotik/zassets. DO NOT MODIFY.{{ with .Tags }}
// +build {{ . | tags }}{{ end }}

package {{ .Package }}

import "github.com/dkotik/zassets"

{{ if eq .Comment "" -}}
	// {{.Variable}} contains static assets.
{{- else -}}
	{{ comment .Comment }}
{{- end }}
var {{ .Variable }} = zassets.Must(zassets.FromBytes([]byte("
{{- end -}}

{{- define "footer" -}}
"))){{ if len .HashTable }}

// {{.Variable}}HashTable associates each entry with a content-based {{ .HashAlgorythm }} hash.
var {{ .Variable }}HashTable = map[string]string{
    {{- range $k, $v := .HashTable }}
    "{{ $k }}": "{{ $v }}",
    {{- end }}
}
{{- end -}}
{{- end -}}`))

// EmbedValues contains fields required for the template.
type EmbedValues struct {
	Variable      string
	Package       string
	Comment       string
	Tags          []string
	HashAlgorythm string
	HashTable     map[string]string
}

func (e *EmbedValues) captureHash(w io.Writer, r io.Reader, p string) (err error) {
	var h hash.Hash
	switch e.HashAlgorythm {
	default: // do nothing
		_, err = io.Copy(w, r)
		return err
	case `md5`:
		h = md5.New()
	case `sha256`:
		h = sha256.New()
	case `xx`:
		h = xxhash.New64()
	}
	w = io.MultiWriter(h, w)
	_, err = io.Copy(w, r)
	e.HashTable[p] = fmt.Sprintf(`%x`, h.Sum([]byte{}))
	return err
}

// EmbedAll zips and embeds the contents of all paths.
func EmbedAll(w io.Writer, v *EmbedValues, i *compile.Iterator) (err error) {
	v.HashTable = make(map[string]string)
	pr, pw := io.Pipe() // TODO: this does not appear to be elegant
	go func() {
		defer pw.Close()
		z := zip.NewWriter(pw)
		defer z.Close()
		z.SetComment(`Resource pack generated by github.com/dkotik/zassets.`)
		err = i.Walk(func(target, relative string, info os.FileInfo) error {
			r, err := os.Open(target)
			if err != nil {
				return err
			}
			defer r.Close()
			h, err := zip.FileInfoHeader(info)
			if err != nil {
				return err
			}
			h.Name = path.Clean(relative)
			h.Method = zip.Deflate
			w, err := z.CreateHeader(h)
			if err != nil {
				return err
			}
			return v.captureHash(w, r, relative)
		})
		// TODO: add a hash table here?
		if err != nil { // TODO: this does not appear elegant at all
			log.Fatal(err)
			// panic()
			// log.Fatalf(`could not zip %s, reason %s`, entry, err.Error())
		}
	}()
	return Embed(w, pr, v, nil)
}

// Embed writes encoded binary data through a template.
func Embed(w io.Writer, r io.Reader, v *EmbedValues, t *template.Template) error {
	if t == nil {
		t = defaultTemplate
	}

	if v.Variable == "" {
		return errors.New("variable name must be specified")
	}
	if v.Package == "" {
		return errors.New("package name must be specified")
	}
	if v.HashAlgorythm != "" && v.HashAlgorythm != "md5" && v.HashAlgorythm != "sha256" && v.HashAlgorythm != "xx" {
		return errors.New("unknown hash algorythm, choose from xx, md5, sha")
	}

	err := t.ExecuteTemplate(w, `header`, v)
	if err != nil {
		return err
	}

	buffer := make([]byte, 1024)
	var i, n int
	for {
		n, err = r.Read(buffer)
		if err != nil {
			break
		}
		for i = 0; i < n; i++ {
			_, err = fmt.Fprintf(w, `\x%02x`, buffer[i])
			if err != nil {
				return err
			}
		}
	}
	return t.ExecuteTemplate(w, `footer`, v)
}
