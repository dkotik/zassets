package zassets

import (
	"errors"
	"fmt"
	"io"
	"log"
	"strconv"
	"strings"
	"text/template"
)

// EmbedFunctions provides helpers for the file generation throug template.
var EmbedFunctions = template.FuncMap{
	"tags": func(tags []string) string {
		return strings.Join(tags, `,`)
	},
	"quote": strconv.Quote,
	"comment": func(s string) string {
		result := strings.SplitAfter(s, "\n")
		return `// ` + strings.Join(result, `// `)
	},
}
var defaultTemplate = template.Must(template.New(`default`).Funcs(EmbedFunctions).Parse(`
{{- define "header" -}}
// Code generated by github.com/dkotik/zassets. DO NOT MODIFY.{{ with .Tags }}
// +build {{ . | tags }}{{ end }}

package {{ .Package }}

import "github.com/dkotik/zassets"

{{ if eq .Comment "" -}}
	// {{.Variable}} contains static assets.
{{- else -}}
	{{ comment .Comment }}
{{- end }}
var {{ .Variable }} = zassets.Must(zassets.FromBytes([]byte("
{{- end -}}

{{- define "footer" -}}
")))
{{- end -}}`))

// EmbedValues contains fields required for the template.
type EmbedValues struct {
	Variable string
	Package  string
	Comment  string
	Tags     []string
}

// EmbedAll zips and embeds the contents of all paths.
func EmbedAll(w io.Writer, v *EmbedValues, p ...string) (err error) {
	z := &zipWriter{}
	pr, pw := io.Pipe()
	go func() {
		defer pw.Close()
		defer z.Close()
		z.Open(pw)
		for _, entry := range p {
			err = z.Add(entry)
			if err != nil {
				log.Fatalf(`could not zip %s, reason %s`, entry, err.Error())
			}
		}
	}()
	return Embed(w, pr, v, nil)
}

// Embed writes encoded binary data through a template.
func Embed(w io.Writer, r io.Reader, v *EmbedValues, t *template.Template) error {
	if t == nil {
		t = defaultTemplate
	}

	if v.Variable == "" {
		return errors.New("variable name must be specified")
	}
	if v.Package == "" {
		return errors.New("package name must be specified")
	}

	err := t.ExecuteTemplate(w, `header`, v)
	if err != nil {
		return err
	}

	buffer := make([]byte, 1024)
	var i, n int
	for {
		n, err = r.Read(buffer)
		if err != nil {
			break
		}
		for i = 0; i < n; i++ {
			_, err = fmt.Fprintf(w, `\x%02x`, buffer[i])
			if err != nil {
				return err
			}
		}
	}
	return t.ExecuteTemplate(w, `footer`, v)
}
